{
  "language": "Solidity",
  "sources": {
    "contracts/DAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n    * DAO contract:\n    * 1. Accumulates money from investors\n    * 2. tracks investor contributions and their weightings via shares\n    * 3. investors can transfer shares\n    * 4. investors can create proposals and vote for them\n    * 5. execute successful proposals\n    */\n\ncontract DAO { \n\n    event contributed(address _investor);\n    event proposalCreated(uint indexed _timestamp, string _name, uint _amount, address indexed _recipient, uint _votes, uint _endTime, bool _executed);\n\n    struct Proposal {\n        /// @notice unique id of proposal\n        uint id;\n        /// @notice name of proposal\n        string name;\n        /// @notice amount of availableFunds sacrificed for proposal\n        uint amount;\n        /// @notice contract address to receive funds and represent the investment\n        address payable recipient;\n        /// @notice total votes for a given proposal\n        uint votes;\n        /// @notice time until proposal finishes\n        uint endTime;\n        /// @notice has the proposal successfully executed?\n        bool executed;\n    }\n    mapping(address => bool) public investors;\n    mapping(address => uint) public shares;\n    mapping(uint => Proposal) public proposals;\n    // e.g. if votes[msg.sender][0] == true, then....\n    mapping(address => mapping(uint => bool)) public votes;\n    // @dev for voting system, determine investor's voting weight\n    uint public totalShares;\n    uint public availableFunds;\n    uint public contributionEnd;\n    uint public nextProposalId;\n    uint public voteTime;\n    uint public quorum;\n    address public admin;\n\n    /**\n        * @notice initializes DAO's timed variables and consensus\n        * @param contributionTime allocated time for investors to invest in DAO\n        * @param _voteTime allocated time to vote on investment proposal\n        * @param _quorum required consensus to execute investment proposal\n        */\n    constructor(\n        uint contributionTime,\n        uint _voteTime,\n        uint _quorum) {\n            require(_quorum > 0 && _quorum < 100, \"quorum must be between 0 and 100\");\n            contributionEnd = block.timestamp + contributionTime;\n            voteTime = _voteTime;\n            quorum = _quorum;\n            admin = msg.sender;\n        }\n\n    function contribute() payable external {\n        require(block.timestamp < contributionEnd, \"cannot contribute after ICO period\");\n        investors[msg.sender] = true;\n        shares[msg.sender] += msg.value;\n        totalShares += msg.value;\n        availableFunds += msg.value;\n        emit contributed(msg.sender);\n    }\n    /// @notice enable investors to redeem their shares from DAO\n    function redeemShare(uint amount) external {\n        // @dev the shares mapping tracks the shares for a given address, so a non-investor can't just redeem shares\n        require(shares[msg.sender] >= amount, \"not enough shares\");\n        require(availableFunds >= amount, \"not enough liquidity to redeem shares\");\n        // TODO: deduct from totalShares too?\n        shares[msg.sender] -=  amount;\n        totalShares -= amount;\n        availableFunds -= amount;\n        // @dev need to typecast msg.sender to payable\n        payable(msg.sender).transfer(amount);\n    }\n    /// @dev func only useful between 2 investors that occurs OUTSIDE of the contract\n    function transferShare(uint amount, address to) external {\n        require(shares[msg.sender] >= amount, \"not enough shares\");\n        shares[msg.sender] -= amount;\n        shares[to] += amount;\n        investors[to] = true; // to addr is now an investor of the DAO\n    }\n    /// @notice investors can create investing proposals for the DAO\n    // TODO: add event emitter - indivudally extract values from mapping\n    // create storage pointer, then pass values to event?? check gas efficiency\n    function createProposal(\n        string memory name,\n        uint amount,\n        address payable recipient\n    ) external onlyInvestors() {\n        require(availableFunds >= amount, \"not enough liquidity for proposal\");\n        proposals[nextProposalId] = Proposal(\n            nextProposalId,\n            name,\n            amount,\n            recipient,\n            0,\n            block.timestamp + voteTime,\n            false\n        );\n        // We could simply use this.balance to get the contract's available ether...\n        // When creating a proposal, we are committing in the FUTURE to spend a PORTION of the available balance...\n        // This reserved amount must be considered when other functions of the contract a called that deduct/add to the available funds\n        // Therefore, the availableFunds will always be <= this.balance\n        availableFunds -= amount;\n        nextProposalId++;\n        emit proposalCreated(block.timestamp, name, amount, recipient, 0, block.timestamp + voteTime, false);\n    }\n    /// @notice vote for a given proposal\n    function vote(uint proposalId) external onlyInvestors() {\n        /// @dev create storage pointer to update proposal more easily\n        Proposal storage proposal = proposals[proposalId];\n        require(votes[msg.sender][proposalId] == false, \"you cannot vote more than once\");\n        require(block.timestamp < proposal.endTime, \"can only vote before proposal end time\");\n        votes[msg.sender][proposalId] = true;\n        proposal.votes += shares[msg.sender];\n    }\n    /// @notice execute the successful proposal\n    // TODO: add event emitter here\n    function executeProposal(uint proposalId) external onlyInvestors() {\n        Proposal storage proposal = proposals[proposalId];\n        require(block.timestamp >= proposal.endTime, \"cannot execute proposal before end time\");\n        require(proposal.executed == false, \"cannot execute proposal already executed\");\n        /// @notice division rounds towards zero and small numbers divided result in 0\n        uint quorumSurpassed = (proposal.votes * 10 ** 2 / totalShares * 10 ** 2) / 100;\n        /// @dev ensure proposal has equalled/surpassed quorum\n        require(quorumSurpassed >= quorum, \"proposal has not satisfied quroum\");\n        proposal.executed = true;\n        _transferEther(proposal.amount, proposal.recipient);\n    }\n\n    /// @notice 'escape hatch' to the extract ether if fuckery occurs\n    function withdraw(uint amount, address payable to) external onlyAdmin() {\n        _transferEther(amount, to);\n    }\n    /**\n        *@notice receive func for receiving ether\n        *@dev do NOT use fallback for primary method of receiving ether as it doesn't fail on 'interface confusions'\n    */\n    receive() payable external {\n        availableFunds += msg.value;\n    }\n\n    function _transferEther(uint amount, address payable to) internal {\n        require(amount <= availableFunds, \"not enough liquidity\");\n        availableFunds -= amount;\n        to.transfer(amount);\n    }\n\n    modifier onlyInvestors() {\n        require(investors[msg.sender] == true, \"only investors\");\n        _;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin\");\n        _;\n    }\n\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}